#!/usr/bin/env python
# coding: utf-8

# ### 时间复杂度和空间复杂度
# 
# 这是任何AI工程师必须要深入理解的概念。对于每一个设计出来的算法都需要从这两个方面来分析
# O(N), O(N^2) : o notation

# In[ ]:


int a = 0, b = 0; 

'''
复杂度是相对于问题的大小的，
排序算法： 问题大小是：要被排序的数组的长度
复杂度：相对于长度（正比，N^2, logN)
'''

for (i = 0; i < N; i++) {
    a = a + rand();  
    b = b + rand();   
}

##2*N = 2N  O(N) 线性复杂度


for (j = 0; j < N/2; j++) { 
    b = b + rand();  1
} 

##1*N/2 = 1/2*N = O(N)

##100*N, 10000000000000*N = O(N)
##常数的意思就是它跟N没有依赖关系

##空间：O(1)


# 时间复杂度？ 空间复杂度？
# 
# 

# In[ ]:


int a = 0; i,j
for (i = 0; i < N; i++) {      
    for (j = N; j > i; j--) { 
        a = a + i + j;  1
    } 
}

##1*N^2 = O(N^2) 时间

##常数空间复杂度O(1)



# In[ ]:


int i, j, k = 0; 
for (i = n / 2; i <= n; i++) {  # O(N)
    for (j = 2; j <= n; j = j * 2) {    # o(logN)
        k = k + n / 2; 
    } 
} 
##时间： (NlogN)
##空间： 常数
##n =40
##j = 2 4 8 16 32


# In[ ]:





# In[ ]:


int a = 0, i = N; 
while (i > 0) {  # log N
    a += i;  # 1个操作
    i /= 2;   #1个操作
} 




# In[ ]:





# 我们每当说算法X的效率要高于Y时指的是？  时间复杂度
# 
# X: o(log n) >  Y: o(n)
#    o(n log n) > Y: o(n^2)
#    
# X实际的效率（秒来） > Y实际的效率（秒） 不一定！！！
# n足够大

# In[ ]:


##定理： if x的时间复杂度要优于y的时间复杂度，那么，假设存在一个足够大的数M，当
##n>M时，我们可以保证X的实际效率要优于Y的实际效率


# In[ ]:


##X > Y  比如N=100, 实际的运行效率有可能Y是更快的。。 但是， M=10^6, N > 10^6, 我们其实可以保证X的实际效率会更高
##x asymtoitically faster than y


